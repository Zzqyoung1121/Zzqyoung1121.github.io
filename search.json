[{"title":"从0到inf，带你了解最短路","url":"/Zzqyoung1121.github.io/2025/08/16/从0到inf，带你了解最短路/","content":"Part 1 基础知识图的概念图是由顶点V的集合和边E的集合组成的二元组：记G=（V，E） 所有边都是双向的图称作无向图，边有方向的图称作有向图。 图的分类有向图无向图无权图带权图连通图二分图… 图的存储与表示邻接矩阵二维数组,$dist[i][j]$对于无权图，dist[i][j]=1表示i到j有边，对于带权图，$dist[i][j]$表示i到j的边权，0表示无边。 优点：好写缺点：空间大，枚举点的出边慢 邻接表通常图方便用vector实现。 优点：空间小，访问速度快，好写缺点：常数比前向星大。 链式前向星把所有边存在一个一维数组，通过head数组访问的方式。 优点：空间小，访问速度快缺点：写起来稍微麻烦 图论的小技巧以及扩展 PART 2 关于最短路定义最短路问题:实际上在图上的问题中，最常被用到的是最短路问题。 最短路问题，实际上就是问，在一幅图中，从u到v最短需要跑多少距离？ 最短路分为单源最短路和多源最短路，实际上就是询问的u只是一个点，还是多个点。 在无权图中，单源最短路直接BFS即可，在此不赘述。后续讨论的最短路问题都是在带权图中。 开始！！！ 多源最短路的floyd算法B3647 【模板】Floyd 【B3647】Floyd 算法 当需要求出任意一对点$(u,v)$的最短路时，使用一个dp是很好解决这个问题的。 $dp[T][i][j]$表示，从i到j的路径中，只能包含编号$1-T$中的点，能够构成的最短路长度是多少。 那么，$dp[T][i][j]=min(dp[T-1][i][T]+dp[T-1][T][j])$也就是，如果路径上经过了T，那么可以拆分成$i-T,T-j$两条路径。 初始状态是$dp[0][i][j]=map[i][j]$，如果没有边可以用$inf$或者$0$来表示。显然可以优化掉第一维。 空间复杂度$O(n^2)$ 时间复杂度$O(n^3)$ floyd求最小环P6175 无向图的最小环问题 题解 P6175 无向图的最小环问题 值得一提的是，floyd还可以在图中，求出长度最小的环。 这个做法还要从没有优化的dp中说起。 $dp[T][i][j]$表示的是从$i$到$j$，经过最多前T个点的最短路长度，那么这时候考虑，如果一个环中最大的点是$T+1$，那么他们的路径构成是什么样的？ $dp[T][i][j]+map[i][T+1]+map[T+1][j]$ 也就是说，当我们求出$dp[T][i][j]$的时候，枚举$i,j<=T$,然后用上述式子更新答案即可。 单源最短路的dijkstra算法P4779 【模板】单源最短路径（标准版） dijkstra 详解 dijkstra是一个贪心思路，首先把距离节点$u$最近的点$v$算出来，因为从$u$到$v$不可能有更短的路了，然后用$map[v][j]+dist[v]$来更新从$u$到$j$的距离。重复上述步骤直到所有点都被算出来。 时间复杂度显然是O$(n^2+m)$的 这个过程一样可以使用一个小根堆来优化，使得时间复杂度变成$O(mlogm)$ 值得注意的是，即便是普通的dijkstra，对每一个节点做一遍单源最短路，也不比floyd慢，所以floyd很多时候是作为好写的存在。 注意：dijkstra是不能处理负权的。 单源最短路的bellman-ford算法bellman-ford更像是floyd的单源dp版。 $dp[i][t]$表示从起点u出发，到i截止，经过最多t步的最短路长度。 显然， $dp[i][1]=map[u][i]$， $dp[i][t]=min(dp[i][t-1],dp[j][t-1]+map[j][i])$ 时间复杂度是$O(n^3)$的 显然，t是多余的，我们可以直接把t扔掉 $dp[i]=min(dp[j]+map[j][i])$ 不停的做这个dp直到所有dp不再变化为止。时间复杂度可以做到最坏$O(n*m)$ bellman-ford的好处是，图中即便有负权，也是可以处理的，但是负环是不能处理的。 但是它的时间复杂度确实比dijkstra要高不少，那么可以从dp的角度对其进行优化，优化后的算法称作SPFA（它已经死了，但好像没死透）。 单源最短路的SPFA算法P3371 【模板】单源最短路径（弱化版） spfa SPFA的核心思想就是，把所有被更新了的点$i$加入到队列中，再枚举所有$i$连接的点$j$，一旦用$i$成功的更新了$j$，就把$j$也加到队列中来（如果$j$本来在队列中就不加了），重复上述步骤直到没有点再能更新别人。 SPFA最坏时间复杂度显然还是$O(nm)$，随机图下面表现是不错的，大约是$O(km)$，$k$是一个10以下的常数。 有两个不错的优化可以让SPFA快一些。 SLF优化：每次要加的点如果比队首好，就加到队首，否则加到队尾。LLL优化：如果当前要处理的节点，比队列中的均值大，就把他丢到队尾，先处理后面的。 这两个优化一起加实测可以快50%的样子，但实际上，卡SPFA的题为什么不用dijkstra呢？ SPFA 判断负环P3385 【模板】负环 P3385 【模板】负环 题解 SPFA还有一个好处是，可以处理负环。想想看，什么情况下一个点会入队超过$N$次呢？ 显然是存在负环的时候，所以当一个点入队次数超过$N$次，就说明图中产生了负环。 实际上还有一个更快的方法，直接在SPFA的过程中，顺便记录这条路径从起点出发，一共走了多少步过来，记做$cnt[i]$，每次用$i$更新$j$的时候，$cnt[j]=cnt[i]+1$，一旦某个点的$cnt[j]>N$，说明产生了负环。 Part 3 差分约束定义如果一个系统由n个变量和m个约束条件组成，形成m个形如$a_i-a_j≤k$的不等式($i,j∈[1,n]$,$k$为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 P5960 【模板】差分约束 题解 P5960 【【模板】差分约束算法】 后记形形色色的最短路 学图论，你真的了解最短路吗？ SPFA算法教学 dijkstra 详解 【图论2-2】最短路 OI_wiki https://oi-wiki.org/graph/shortest-path/ https://oi-wiki.org/graph/diff-constraints/ https://oi-wiki.org/graph/kth-path/ https://oi-wiki.org/graph/mod-shortest-path/","date":"2025-08-16","tags":["算法·理论"]},{"title":"Hello World","url":"/Zzqyoung1121.github.io/2025/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment","date":"2025-08-15"}]