[{"title":"Hello World","url":"/Zzqyoung1121.github.io/2025/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment","date":"2025-08-15"},{"title":"题解：P5788 【模板】单调栈","url":"/Zzqyoung1121.github.io/2025/08/04/题解：P5788 【模板】单调栈/","content":"单调栈 单调栈-OI wiki P5788 【模板】单调栈 题面描述 给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。 定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的下标，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} {j}$。若不存在，则 $f(i)=0$。 试求出 $f(1\\dots n)$。 对于 $100%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。 算法引入 单调栈，顾名思义，就是站内保证单调的栈（数据结构）。 根据这个（优美的）性质，我们不难发现，可以用它在 $ O(n)$ 的时间复杂度内处理一类常见的问题： 定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后（前）第一个大于（或小于） $a_i$ 的元素的下标，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} {j}$。若不存在，则 $f(i)=0$。 试求出 $f(1\\dots n)$。 –来源：P5788 【模板】单调栈（内容有所修改） 算法详解 根据单调栈内的顺序，我们可以分为两种： 单调递增栈 单调递减栈 e.g. 对于本题（维护第 $i$ 个元素之后（前）第一个大于（或小于） $a_i$ 的元素的下标）， 我们考虑维护一个单调下降的栈，从后往前枚举每一个 $a_i$ ，找到栈中第一个比 $a_i$ 大的位置，保证栈的单调性。 我们是将下标压栈，不是将元素压栈，但是是以元素作为标准比较 算法演示 对于这个样例 $i=1$: 我们考虑将 $5$ 压栈的位置，发现可以将 $5$ 放在栈顶，因为此时栈为空，所以 $f(5)=-1$，然后将 $5$ 压栈 栈中：$5(5)$ $i=2$: 我们考虑将 $4$ 压栈的位置，发现可以将 $4$ 放在栈顶，此时栈顶为 $5$，所以 $f(4)=5$，然后将 $4$ 压栈 栈中：$5(5),4(3)$ $i=3$: 我们考虑将 $3$ 压栈的位置，发现可以将 $3$ 放在栈顶，此时栈顶为 $4$，所以 $f(3)=4$，然后将 $3$ 压栈 栈中：$5(5),4(3),3(2)$ $i=4$: 我们考虑将 $3$ 压栈的位置，发现不可以将 $3$ 放在栈顶，因为将 $2$ 压栈，但是直接将 $2$ 压栈会导致栈中为： $5(5),4(4),3(2),2(4)$ 不单调下降！，于是我们弹栈：将栈中每个小标所对应的元素（括号中的数）大于 $4$ 的数全部弹出 此时的栈： $5(5)$ 此时栈顶为 $5$ ，所以 $f(2)=5$，再压入 $2$ 栈中：$5(5),2(4)$ $i=5$: 此时栈顶为 $2$ ，所以 $f(1)=2$，结束 所以可以求出答案： $2,5,4,5,-1$ AC代码 后记–更改记录 update.$2025.8.4$ 完稿 update.$2025.8.7$ 被打回，详细写了算法演示部分","date":"2025-08-04","tags":["题解"]},{"title":"从0到inf，带你了解最短路","url":"/Zzqyoung1121.github.io/2025/07/23/从0到inf，带你了解最短路/","content":"Part 1 基础知识 图的概念 图是由顶点V的集合和边E的集合组成的二元组：记G=（V，E） 所有边都是双向的图称作无向图，边有方向的图称作有向图。 图的分类 有向图 无向图 无权图 带权图 连通图 二分图 … 图的存储与表示 邻接矩阵 二维数组,$dist[i][j]$对于无权图，dist[i][j]=1表示i到j有边，对于带权图，$dist[i][j]$表示i到j的边权，0表示无边。 优点：好写 缺点：空间大，枚举点的出边慢 邻接表 通常图方便用vector实现。 优点：空间小，访问速度快，好写 缺点：常数比前向星大。 链式前向星 把所有边存在一个一维数组，通过head数组访问的方式。 优点：空间小，访问速度快 缺点：写起来稍微麻烦 图论的小技巧以及扩展 PART 2 关于最短路 定义 最短路问题:实际上在图上的问题中，最常被用到的是最短路问题。 最短路问题，实际上就是问，在一幅图中，从u到v最短需要跑多少距离？ 最短路分为单源最短路和多源最短路，实际上就是询问的u只是一个点，还是多个点。 在无权图中，单源最短路直接BFS即可，在此不赘述。 后续讨论的最短路问题都是在带权图中。 开始！！！ 多源最短路的floyd算法 B3647 【模板】Floyd 【B3647】Floyd 算法 当需要求出任意一对点$(u,v)$的最短路时， 使用一个dp是很好解决这个问题的。 $dp[T][i][j]$表示，从i到j的路径中，只能包含编号$1-T$中的点，能够构成的最短路长度是多少。 那么，$dp[T][i][j]=min(dp[T-1][i][T]+dp[T-1][T][j])$也就是，如果路径上经过了T，那么可以拆分成$i-T,T-j$两条路径。 初始状态是$dp[0][i][j]=map[i][j]$，如果没有边可以用$inf$或者$0$来表示。显然可以优化掉第一维。 空间复杂度$O(n^2)$ 时间复杂度$O(n^3)$ floyd求最小环 P6175 无向图的最小环问题 题解 P6175 无向图的最小环问题 值得一提的是，floyd还可以在图中，求出长度最小的环。 这个做法还要从没有优化的dp中说起。 $dp[T][i][j]$表示的是从$i$到$j$，经过最多前T个点的最短路长度，那么这时候考虑，如果一个环中最大的点是$T+1$，那么他们的路径构成是什么样的？ $dp[T][i][j]+map[i][T+1]+map[T+1][j]$ 也就是说，当我们求出$dp[T][i][j]$的时候，枚举$i,j<=T$,然后用上述式子更新答案即可。 单源最短路的dijkstra算法 P4779 【模板】单源最短路径（标准版） dijkstra 详解 dijkstra是一个贪心思路，首先把距离节点$u$最近的点$v$算出来，因为从$u$到$v$不可能有更短的路了，然后用$map[v][j]+dist[v]$来更新从$u$到$j$的距离。重复上述步骤直到所有点都被算出来。 时间复杂度显然是O$(n^2+m)$的 这个过程一样可以使用一个小根堆来优化，使得时间复杂度变成 $O(mlogm)$ 值得注意的是，即便是普通的dijkstra，对每一个节点做一遍单源最短路，也不比floyd慢，所以floyd很多时候是作为好写的存在。 注意：dijkstra是不能处理负权的。 单源最短路的bellman-ford算法 bellman-ford更像是floyd的单源dp版。 $dp[i][t]$表示从起点u出发，到i截止，经过最多t步的最短路长度。 显然， $dp[i][1]=map[u][i]$， $dp[i][t]=min(dp[i][t-1],dp[j][t-1]+map[j][i])$ 时间复杂度是$O(n^3)$的 显然，t是多余的，我们可以直接把t扔掉 $dp[i]=min(dp[j]+map[j][i])$ 不停的做这个dp直到所有dp不再变化为止。 时间复杂度可以做到最坏$O(n*m)$ bellman-ford的好处是，图中即便有负权，也是可以处理的，但是负环是不能处理的。 但是它的时间复杂度确实比dijkstra要高不少，那么可以从dp的角度对其进行优化，优化后的算法称作SPFA（它已经死了，但好像没死透）。 单源最短路的SPFA算法 P3371 【模板】单源最短路径（弱化版） spfa SPFA的核心思想就是，把所有被更新了的点$i$加入到队列中，再枚举所有$i$连接的点$j$，一旦用$i$成功的更新了$j$，就把$j$也加到队列中来（如果$j$本来在队列中就不加了），重复上述步骤直到没有点再能更新别人。 SPFA最坏时间复杂度显然还是$O(nm)$，随机图下面表现是不错的，大约是$O(km)$，$k$是一个10以下的常数。 有两个不错的优化可以让SPFA快一些。 SLF优化：每次要加的点如果比队首好，就加到队首，否则加到队尾。 LLL优化：如果当前要处理的节点，比队列中的均值大，就把他丢到队尾，先处理后面的。 这两个优化一起加实测可以快50%的样子，但实际上，卡SPFA的题为什么不用dijkstra呢？ SPFA 判断负环 P3385 【模板】负环 P3385 【模板】负环 题解 SPFA还有一个好处是，可以处理负环。想想看，什么情况下一个点会入队超过$N$次呢？ 显然是存在负环的时候，所以当一个点入队次数超过$N$次，就说明图中产生了负环。 实际上还有一个更快的方法，直接在SPFA的过程中，顺便记录这条路径从起点出发，一共走了多少步过来，记做$cnt[i]$，每次用$i$更新$j$的时候，$cnt[j]=cnt[i]+1$，一旦某个点的$cnt[j]>N$，说明产生了负环。 Part 3 差分约束 定义 如果一个系统由n个变量和m个约束条件组成，形成m个形如$a_i-a_j≤k$的不等式($i,j∈[1,n]$,$k$为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 P5960 【模板】差分约束 题解 P5960 【【模板】差分约束算法】 后记 形形色色的最短路 学图论，你真的了解最短路吗？ SPFA算法教学 dijkstra 详解 【图论2-2】最短路 OI_wiki https://oi-wiki.org/graph/shortest-path/ https://oi-wiki.org/graph/diff-constraints/ https://oi-wiki.org/graph/kth-path/ https://oi-wiki.org/graph/mod-shortest-path/","date":"2025-07-23","tags":["算法·理论"]},{"title":"题解：P1439 【模板】最长公共子序列","url":"/Zzqyoung1121.github.io/2025/03/12/题解：P1439 【模板】最长公共子序列/","content":"P1439 【模板】最长公共子序列 思路 对于两个为自然数 $1,2,\\ldots,n$ 的排列，他们其中的元素是一样的，只有顺序不同。则可以通过结构体，记录每一个 $a_i$ 的下标,在对 $a_i$ 进行结构体排序。 然后，就把问题转化成了 $ a_{b_i}.id $ 的 LIS 。 时间复杂度 $ O(n\\times(\\log_2 n)) $ 代码 LIS","date":"2025-03-12","tags":["题解"]}]