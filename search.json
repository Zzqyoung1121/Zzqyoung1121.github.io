[{"title":"比赛总结","url":"/Zzqyoung1121.github.io/2025/08/18/比赛总结/","content":"NOIP2025模拟赛15 https://www.luogu.com.cn/article/xqt2mfbc 未完成题目： T2 算法标签：组合数学，DP T3 算法标签：期望，点分治 T4 略 NOIP2025模拟赛16 未完成题目： T1 算法标签：贪心，换根DP T2 算法标签：组合数学，计数DP T3 算法标签：点双联通，圆方树，lca T4 略 2025模拟赛9 https://www.luogu.com.cn/article/31a2qck6 未完成题目： T3 算法标签：其他，双指针扫描，数据结构，并查集 T4 算法标签：动态规划 T5 算法标签：动态规划，状压DP T6 算法标签：其他，数据结构，线段树，二分查找 NOIP2025模拟赛18 未完成题目： T1 算法标签：背包DP，复杂度计算 T2 算法标签：数据结构，并查集，LCA，树的直径 T3 算法标签：数据结构，线段树，分段函数 T4 略 NOIP2025模拟赛19 https://www.luogu.com.cn/article/vwwgwosj 未完成题目： T1 算法标签：数据结构，线段树，树状数组，组合数学 ，容斥原理 T2 算法标签：组合数学，数论 T3 算法标签：其他，打表，构造 T4 略 NOIP2025模拟赛20 https://www.luogu.com.cn/article/x3x7t2ju 未完成题目： T2 算法标签：贪心，优先队列 T3 略 T4 略 NOIP2025模拟赛21 https://www.luogu.com.cn/article/wfy7cezp 未完成题目： T1 算法标签：贪心 T2 算法标签：DP，树上DP T3 略 T4 略 2025模拟赛10 https://www.luogu.com.cn/article/wypdja50 未完成题目： T3 算法标签：搜索，枚举，动态规划，树上DP T5 算法标签：其他，二分查找，动态规划，贪心 T6 算法标签：搜索，记忆化搜索，枚举，模拟 NOIP2025模拟赛23 https://www.luogu.com.cn/article/878bfrpv 未完成题目： T1 算法标签：数据结构，并查集，BFS T2 算法标签：数据结构，树套树，STL T3 算法标签：贪心，DP，二分 T4 算法标签：贪心，启发式合并 NOIP2025模拟赛24 https://www.luogu.com.cn/article/fiux2tn4 未完成题目： T2 略 T3 算法标签：模拟，递推，其他，二分查找，数学，分块 T4 略 NOIP2025模拟赛25 https://www.luogu.com.cn/article/yccixlk5 未完成题目： T1 算法标签：DP，结论题 T2 算法标签：仙人掌，LCA T3 算法标签：组合数学，DP T4 略 NOIP2025模拟赛26 https://www.luogu.com.cn/article/ptkemq7y 未完成题目： T1 算法标签：贪心，其他，构造 T2 算法标签：贪心，倍增，二分 T3 算法标签：其他，分块，数据结构，线段树，数学 T4 算法标签：重构树，DP，DFS","date":"2025-08-18","tags":["比赛总结"]},{"title":"从零搭建 Github+Hexo 博客","url":"/Zzqyoung1121.github.io/2025/08/16/从零搭建 Github+Hexo 博客/","content":"前言 之前有一篇用 $\\text{Wordpress}$ 搭建博客的文章，这里给出一种更为方便的搭建方法，只要用 $\\text{Github}$。 笔者是在 $\\text{Windows}$ 的环境下搭建的，其他系统可能不适用。 本文同步发表于笔者的博客：从零搭建 Hexo + Github 博客 感谢 @Happynewyear 的帮忙捉虫，以及 @Sinner 提供的部分程序地址。 优缺点分析 优点 安装简单方便，不需要自己找域名、设置 $\\text{DNS}$，自带 $\\text{Markdown}$，在简单的设置之后即可支持 $\\LaTeX$。同时官网有诸多主题可供挑选。 缺点 搭建在 $\\text{Github}$ 的服务器上，访问速度较慢，无法自定义域名，想要对博客进行自定义更改需要使用 $\\text{JavaScript}$，博客上传比较麻烦。 前置条件 程序 在开始之前，推荐大家提前下载一下之后要用到的程序，如下： $\\text{Node.js}$ $\\text{Git}$ $\\text{Sublime}$ 账号 我们只需要一个 $\\text{Github}$ 的账号即可。 开始搭建 1. 配置 $\\text{Github}$ 的 $\\text{SHH}$ 首先进入 $\\text{Git}$ 程序的源文件夹，打开 git-bash.exe。 输入这样一行命令： 按下回车，按四次，直到出现一个奇怪的图时，则完成。图可能会不同，属于正常现象。 此时就不用管了，我们进入 $\\text{Github}$ ，登录自己的账号，点击右上角头像 $\\rightarrow$ $\\text{Settings}$， 然后点击左侧的 $\\text{SSH and GPG keys}$ 点击右上方的 $\\text{New SSH key}$ 此时会让你填两个东西，一个是 $\\text{Title}$，一个是 $\\text{Key}$，前者我们随便填一个，后者的话，我们进入 C:\\Users\\你的用户名\\.ssh，用记事本打开一个叫做 id_rsa.pub 的文件，把里面的东西复制到 $\\text{Key}$ 里面去即可。 2. 本地运行 $\\text{Hexo}$ 首先进入 $\\text{Hexo}$ 的官网，此时我们会在正中间看见一行代码，这个就是 $\\text{Hexo}$ 的安装代码了。 在安装之前，我们要准备一个东西：存储本地博客的文件夹，这个大家按自己的习惯和情况创建一个文件夹就行，比如我创建的文件夹是 E:/blog，这个 blog 文件夹就是存储所有博客要用的文件夹了。 为避免出现不必要的 $\\text{Bug}$，推荐使用英文的文件夹名字。 在安装时，各位应该按照自己的路径来设置，千万不要完全照搬这里给出的做法。 我们打开 cmd（win+R 键打开运行，输入 cmd），先输入盘，比如我这里是 E:，然后输入 cd blog，然后打入给出的那行命令：npm install hexo-cli -g，等到进度条满，你能够再次输入命令时就完成了。 先别急着关 cmd，之后我们还会用到。 此时我们就要开始创建本地博客了。在 $\\text{Hexo}$ 官网首页的下方，有一行代码，hexo init blog，这行代码就是我们创建博客的关键了。此时，如果你没有关掉 cmd，那么它应该是保持着 cd 到你创建的文件夹的状态，如果关掉的话，要重新 E: cd blog 一下。输入官网上的这行代码：hexo init 你的博客名，这个博客名随便起，因为它不会影响你网站上的任何因素，只是会影响之后创建的文件夹的名字。 输入代码，开始创建博客，又需要一些时间。当然，有一些写着 WARN 的指令行出现，也不用紧张，是正常现象。 等待安装完成，需要一些时间。 安装好之后，我们就可以看见之前的 blog 文件夹中，出现了一个名字为你刚刚输入的名字文件夹。 我们 cd 到这个文件夹下，对我来说就是 cd vocaloid，然后就可以安装依赖了，输入 npm install，开始安装。 这个很快就可以完成。 接着我们就可以本地运行了，我们接着在 cmd 中输入 hexo s -p 端口，这个端口不知道有什么限制，推荐输入 5555 或者 4000，很快就可以完成。 此时我们就可以进入 localhost:端口，就可以看到你的 $\\text{Hexo}$ 博客啦。 此时如果你在 cmd 中按下 Ctrl+C，再确认终止批处理操作，就可以停止使用这个端口了。 3. 发布至 $\\text{Github}$ 在上传之前，我们需要做一些配置。首先用 $\\text{Sublime}$ 打开文件夹： 打开 _config.yml，准备修改。 进入 $\\text{Github}$，先新建一个项目，点击右上角的 $+$ 号，选择 New repository，描述自己填，名字使用 你的 Github 用户名.github.io。 （因为我这里是一个号重复建，所以我就不用我的用户名演示了。） （一定要用 你的 Github 用户名.github.io 作为项目名字，二次强调） 为了防止接下来的教程出现一些问题，各位最好把“是否有 README” 这一个选项选上，不然就会和我这里给出的情况不同。 此时就进入了项目的页面，我们点击右侧绿色的 Clone or download 按钮，将它给出的链接复制下来。 回到 $\\text{Sublime}$，拉到最下面，在 type 后面输入 git（所有冒号后面都有空格，不能不加，切记）。 在 type 这一行下面，加入 repo: ，然后后面填上刚刚复制的地址，往上拉，找到 url:，在 url: 后面输入：http://你的 Github 用户名.github.io 上方有一个 author，这个可以改一下，改成你自己即可。 此时基础配置就差不多完成了，我们回到 cmd，先退出刚才的本地端口，然后安装一个 $\\text{Git}$ 插件。 输入 npm install hexo-deployer-git --save ，即可等待其安装了。 此时回到 $\\text{Sublime}$，在刚刚的 repo 下面再加一行：branch: master，保存。 完成后，我们就可以尝试运行这个博客了。我们在 cmd 中分别输入两行代码，一行是 hexo g，代表本地文件生成，另一行是 hexo d，代表上传。 等待一些时间，即可完成。 此时会让你配置你的 $\\text{Github}$ 账号，需要分别输入两行代码（因为我之前配置过了，所以不用再次配置），如下（这两行代码在 cmd 中都有给出）： git config --global user.email \"你的邮箱\" git config --global user.name \"你的用户名\" 引号不要省略掉。配置好后，再次输入 hexo d，此时会弹出一个窗口，让你登录你的 $\\text{Github}$，大概长这样： 登录就行了。等到上传完成，即可直接访问你的博客了，地址就是你刚才在 $\\text{Sublime}$ 中，url: 后面的那个地址。 此时就完成了博客的搭建，但是我们的博客是不支持 $\\LaTeX$ 的，所以我们还需要配置。 4. $404$ 的解决方案 我们可能会遇到这样的情况： 这种情况必然是非常令人恼火的，但解决方法非常简单，我们进入刚才创建的项目的页面，点击 $Settings$，往下拉，找到一个 Custom domain，输入我们之前在 url: 后面输入的那个域名，即 <用户名>.github.io，然后点击 $\\text{Save}$，应该就可以访问了。 5. 主题 不同的主题可以在 $\\text{Hexo}$ 的 主题 中安装，只需要在 cmd 中 cd 到你的博客文件夹（对我来说是 E:\\blog\\vocaloid），然后在主题的 $\\text{Github}$ 中找到安装的代码，如果没有大家可以自行修改别的代码，将地址和文件夹改一下就行了。 （UPD: 改了可能不能正常使用，建议不要改） 之后我们可以打开 _config.yml，将下面的 theme: 后面的名字改成安装的文件夹的名字，比如 theme: next。 6. 博客的标题 打开 _config.yml，可以看到上方有一个 title: ，把后面的修改掉就行了。 $\\LaTeX$ 设置 我们此时搭建的博客只能使用 $\\text{Markdown}$，同时因为一些语句的冲突无法使用 $\\LaTeX$ ，所以我们需要解决这些冲突，同时安装一个能够使用及渲染 $\\LaTeX$ 的语言包。 下面的操作都默认 cd 到了博客文件夹。 1. 修改引擎 首先我们要将原本的渲染引擎替换成能够支持 $\\LaTeX$ 的渲染引擎。原版的引擎是 $\\text{Marked}$，我们将它卸载 ，然后安装一个 $\\text{Kramed}$ 引擎。 先 cd 到博客文件夹后，输入以下代码： npm uninstall hexo-renderer-marked --save npm install hexo-renderer-kramed --save 2. 更改配置 用 $\\text{Sublime}$ 打开 /node_modules/hexo-renderer-kramed/lib/renderer.js 。 3. 修改数学包 我们要将原来的数学包修改成 $\\text{Kramed}$ 适用的数学包，分别输入 npm uninstall hexo-math --save npm install hexo-renderer-mathjax --save 等待其卸载、安装即可。 4. 更新配置文件 打开 /node_modules/hexo-renderer-mathjax/mathjax.html，将最下面的代码注释掉（即在开始的 < 后面加上 !-- ，然后在上面加上一行：<script src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML\"></script> 即可。 5. 更改规则 为了解决冲突，我们还需要更改转义规则。首先打开 \\node_modules\\kramed\\lib\\rules\\inline.js，将 escape 和 em 这两行注释掉，分别修改为： 至此，我们完成了 $\\LaTeX$ 的前置准备，最后只需要启用即可。 6. 启用 进入进入 博客\\_config.yml，加上一行 mathjax: true 即可。如果不行的话，就在每篇博客最前面的信息处加上一行 mathjax: true 即可。 如何上传博客 我们进入 博客名\\source\\_posts，这里就是放博客的地方。如果要写博客，最好使用一些 $\\text{Markdown}$ + $\\LaTeX$ 编辑器，比如 $\\text{Typora}$，在本地写好后，在放博客的地方新建一个文档，文档的名字就决定了你的标识符，也就是这个东西： 文档的后缀名应该是 .md，我们可以创建一个 .txt 文件，然后改后缀就行。用 $\\text{Sublime}$ 或者别的编辑器打开后，我们在最上面加上这样一段： 然后再下面直接把博客复制上去就行。 此时我们就写好了一篇博客，但是我们还需要上传，我们打开 cmd，cd 到你的博客的位置，然后分别输入三行代码： hexo clean hexo g hexo d 等待一段时间后再回到博客，就可以成功了。 效果见：Here 文章过长？ 我们会发现，上传博客后往往会在首页将整篇文章的内容都显示出来，这显然是非常占用空间的，此时我们可以在博客的文档中加入一行代码：<!--more-->，然后重新上传，此时在这行代码后面的内容都不会显示出来了，而是改为了一个“$\\text{Read More}$”按键，非常方便。 博客背景 进入 \\themes\\landscape\\source\\css\\images，有一张叫做 banner.jpg/png 的图（不同主题的位置及名字都可能不同），我们将它替换，文件名和后缀名最好都一样，然后按照上面传博客的方法，hexo clean，hexo g，hexo d，等一会儿就上传完成了。 注意：基本上所有修改完成后都要打一遍 hexo clean，hexo g，hexo d，忘记打就会导致修改在网站上无法生效。 小结 这里只是给出了一些最基础的内容，各位想要更深的研究可以在网上找一些教程，也可以套用现有的主题，难度应该不会很大（当然，如果涉及 $\\text{JS}$ 那也不简单了【笑】）。 参考资料：1 2 3 转载自VenusM1nT","date":"2025-08-16","tags":["科技·工程"]},{"title":"Hello World","url":"/Zzqyoung1121.github.io/2025/08/15/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment","date":"2025-08-15"},{"title":"题解：P5788 【模板】单调栈","url":"/Zzqyoung1121.github.io/2025/08/04/题解：P5788 【模板】单调栈/","content":"单调栈 单调栈-OI wiki P5788 【模板】单调栈 题面描述 给出项数为 $n$ 的整数数列 $a_{1 \\dots n}$。 定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的下标，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} {j}$。若不存在，则 $f(i)=0$。 试求出 $f(1\\dots n)$。 对于 $100%$ 的数据，$1 \\le n\\leq 3\\times 10^6$，$1\\leq a_i\\leq 10^9$。 算法引入 单调栈，顾名思义，就是站内保证单调的栈（数据结构）。 根据这个（优美的）性质，我们不难发现，可以用它在 $ O(n)$ 的时间复杂度内处理一类常见的问题： 定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后（前）第一个大于（或小于） $a_i$ 的元素的下标，即 $f(i)=\\min_{i<j\\leq n, a_j > a_i} {j}$。若不存在，则 $f(i)=0$。 试求出 $f(1\\dots n)$。 –来源：P5788 【模板】单调栈（内容有所修改） 算法详解 根据单调栈内的顺序，我们可以分为两种： 单调递增栈 单调递减栈 e.g. 对于本题（维护第 $i$ 个元素之后（前）第一个大于（或小于） $a_i$ 的元素的下标）， 我们考虑维护一个单调下降的栈，从后往前枚举每一个 $a_i$ ，找到栈中第一个比 $a_i$ 大的位置，保证栈的单调性。 我们是将下标压栈，不是将元素压栈，但是是以元素作为标准比较 算法演示 对于这个样例 $i=1$: 我们考虑将 $5$ 压栈的位置，发现可以将 $5$ 放在栈顶，因为此时栈为空，所以 $f(5)=-1$，然后将 $5$ 压栈 栈中：$5(5)$ $i=2$: 我们考虑将 $4$ 压栈的位置，发现可以将 $4$ 放在栈顶，此时栈顶为 $5$，所以 $f(4)=5$，然后将 $4$ 压栈 栈中：$5(5),4(3)$ $i=3$: 我们考虑将 $3$ 压栈的位置，发现可以将 $3$ 放在栈顶，此时栈顶为 $4$，所以 $f(3)=4$，然后将 $3$ 压栈 栈中：$5(5),4(3),3(2)$ $i=4$: 我们考虑将 $3$ 压栈的位置，发现不可以将 $3$ 放在栈顶，因为将 $2$ 压栈，但是直接将 $2$ 压栈会导致栈中为： $5(5),4(4),3(2),2(4)$ 不单调下降！，于是我们弹栈：将栈中每个小标所对应的元素（括号中的数）大于 $4$ 的数全部弹出 此时的栈： $5(5)$ 此时栈顶为 $5$ ，所以 $f(2)=5$，再压入 $2$ 栈中：$5(5),2(4)$ $i=5$: 此时栈顶为 $2$ ，所以 $f(1)=2$，结束 所以可以求出答案： $2,5,4,5,-1$ AC代码 后记–更改记录 update.$2025.8.4$ 完稿 update.$2025.8.7$ 被打回，详细写了算法演示部分","date":"2025-08-04","tags":["题解"]},{"title":"从0到inf，带你了解最短路","url":"/Zzqyoung1121.github.io/2025/07/23/从0到inf，带你了解最短路/","content":"Part 1 基础知识 图的概念 图是由顶点V的集合和边E的集合组成的二元组：记G=（V，E） 所有边都是双向的图称作无向图，边有方向的图称作有向图。 图的分类 有向图 无向图 无权图 带权图 连通图 二分图 … 图的存储与表示 邻接矩阵 二维数组,$dist[i][j]$对于无权图，dist[i][j]=1表示i到j有边，对于带权图，$dist[i][j]$表示i到j的边权，0表示无边。 优点：好写 缺点：空间大，枚举点的出边慢 邻接表 通常图方便用vector实现。 优点：空间小，访问速度快，好写 缺点：常数比前向星大。 链式前向星 把所有边存在一个一维数组，通过head数组访问的方式。 优点：空间小，访问速度快 缺点：写起来稍微麻烦 图论的小技巧以及扩展 PART 2 关于最短路 定义 最短路问题:实际上在图上的问题中，最常被用到的是最短路问题。 最短路问题，实际上就是问，在一幅图中，从u到v最短需要跑多少距离？ 最短路分为单源最短路和多源最短路，实际上就是询问的u只是一个点，还是多个点。 在无权图中，单源最短路直接BFS即可，在此不赘述。 后续讨论的最短路问题都是在带权图中。 开始！！！ 多源最短路的floyd算法 B3647 【模板】Floyd 【B3647】Floyd 算法 当需要求出任意一对点$(u,v)$的最短路时， 使用一个dp是很好解决这个问题的。 $dp[T][i][j]$表示，从i到j的路径中，只能包含编号$1-T$中的点，能够构成的最短路长度是多少。 那么，$dp[T][i][j]=min(dp[T-1][i][T]+dp[T-1][T][j])$也就是，如果路径上经过了T，那么可以拆分成$i-T,T-j$两条路径。 初始状态是$dp[0][i][j]=map[i][j]$，如果没有边可以用$inf$或者$0$来表示。显然可以优化掉第一维。 空间复杂度$O(n^2)$ 时间复杂度$O(n^3)$ floyd求最小环 P6175 无向图的最小环问题 题解 P6175 无向图的最小环问题 值得一提的是，floyd还可以在图中，求出长度最小的环。 这个做法还要从没有优化的dp中说起。 $dp[T][i][j]$表示的是从$i$到$j$，经过最多前T个点的最短路长度，那么这时候考虑，如果一个环中最大的点是$T+1$，那么他们的路径构成是什么样的？ $dp[T][i][j]+map[i][T+1]+map[T+1][j]$ 也就是说，当我们求出$dp[T][i][j]$的时候，枚举$i,j<=T$,然后用上述式子更新答案即可。 单源最短路的dijkstra算法 P4779 【模板】单源最短路径（标准版） dijkstra 详解 dijkstra是一个贪心思路，首先把距离节点$u$最近的点$v$算出来，因为从$u$到$v$不可能有更短的路了，然后用$map[v][j]+dist[v]$来更新从$u$到$j$的距离。重复上述步骤直到所有点都被算出来。 时间复杂度显然是O$(n^2+m)$的 这个过程一样可以使用一个小根堆来优化，使得时间复杂度变成 $O(mlogm)$ 值得注意的是，即便是普通的dijkstra，对每一个节点做一遍单源最短路，也不比floyd慢，所以floyd很多时候是作为好写的存在。 注意：dijkstra是不能处理负权的。 单源最短路的bellman-ford算法 bellman-ford更像是floyd的单源dp版。 $dp[i][t]$表示从起点u出发，到i截止，经过最多t步的最短路长度。 显然， $dp[i][1]=map[u][i]$， $dp[i][t]=min(dp[i][t-1],dp[j][t-1]+map[j][i])$ 时间复杂度是$O(n^3)$的 显然，t是多余的，我们可以直接把t扔掉 $dp[i]=min(dp[j]+map[j][i])$ 不停的做这个dp直到所有dp不再变化为止。 时间复杂度可以做到最坏$O(n*m)$ bellman-ford的好处是，图中即便有负权，也是可以处理的，但是负环是不能处理的。 但是它的时间复杂度确实比dijkstra要高不少，那么可以从dp的角度对其进行优化，优化后的算法称作SPFA（它已经死了，但好像没死透）。 单源最短路的SPFA算法 P3371 【模板】单源最短路径（弱化版） spfa SPFA的核心思想就是，把所有被更新了的点$i$加入到队列中，再枚举所有$i$连接的点$j$，一旦用$i$成功的更新了$j$，就把$j$也加到队列中来（如果$j$本来在队列中就不加了），重复上述步骤直到没有点再能更新别人。 SPFA最坏时间复杂度显然还是$O(nm)$，随机图下面表现是不错的，大约是$O(km)$，$k$是一个10以下的常数。 有两个不错的优化可以让SPFA快一些。 SLF优化：每次要加的点如果比队首好，就加到队首，否则加到队尾。 LLL优化：如果当前要处理的节点，比队列中的均值大，就把他丢到队尾，先处理后面的。 这两个优化一起加实测可以快50%的样子，但实际上，卡SPFA的题为什么不用dijkstra呢？ SPFA 判断负环 P3385 【模板】负环 P3385 【模板】负环 题解 SPFA还有一个好处是，可以处理负环。想想看，什么情况下一个点会入队超过$N$次呢？ 显然是存在负环的时候，所以当一个点入队次数超过$N$次，就说明图中产生了负环。 实际上还有一个更快的方法，直接在SPFA的过程中，顺便记录这条路径从起点出发，一共走了多少步过来，记做$cnt[i]$，每次用$i$更新$j$的时候，$cnt[j]=cnt[i]+1$，一旦某个点的$cnt[j]>N$，说明产生了负环。 Part 3 差分约束 定义 如果一个系统由n个变量和m个约束条件组成，形成m个形如$a_i-a_j≤k$的不等式($i,j∈[1,n]$,$k$为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。 P5960 【模板】差分约束 题解 P5960 【【模板】差分约束算法】 后记 形形色色的最短路 学图论，你真的了解最短路吗？ SPFA算法教学 dijkstra 详解 【图论2-2】最短路 OI_wiki https://oi-wiki.org/graph/shortest-path/ https://oi-wiki.org/graph/diff-constraints/ https://oi-wiki.org/graph/kth-path/ https://oi-wiki.org/graph/mod-shortest-path/","date":"2025-07-23","tags":["算法·理论"]},{"title":"题解：P1439 【模板】最长公共子序列","url":"/Zzqyoung1121.github.io/2025/03/12/题解：P1439 【模板】最长公共子序列/","content":"P1439 【模板】最长公共子序列 思路 对于两个为自然数 $1,2,\\ldots,n$ 的排列，他们其中的元素是一样的，只有顺序不同。则可以通过结构体，记录每一个 $a_i$ 的下标,在对 $a_i$ 进行结构体排序。 然后，就把问题转化成了 $ a_{b_i}.id $ 的 LIS 。 时间复杂度 $ O(n\\times(\\log_2 n)) $ 代码 LIS","date":"2025-03-12","tags":["题解"]},{"title":"亲爱的小粉兔--xht","url":"/Zzqyoung1121.github.io/2024/03/01/亲爱的小粉兔/","content":"… 根据上述材料，给将要离任的小粉兔写一篇小作文。 ChatGPT 亲爱的小粉兔： 时光荏苒，眨眼间，你即将离开我们了。在这个告别的时刻，我想表达我对你的深深感激和最诚挚的祝福。 回首我们一起度过的时光，你那魔怔而又独特的个性总是给我们带来无尽的乐趣。你的笑容、你的言行举止，总是让人忍俊不禁。无论是在工作中还是生活中，你总是能够以自己独特的方式照亮周围的一切。 虽然有时你会显得有些优柔寡断，但正是这种特点让你更加人性化、更加接地气。你的执着，让我们见识到了你对于工作的认真和责任心。即便面对困难和挑战，你也从不轻言放弃，而是坚定地追求着自己的目标。 在你离开之际，我想对你说声谢谢。谢谢你为我们带来的欢笑和快乐，谢谢你为我们所做的一切努力和付出。虽然我们将会想念你，但我们也相信你在新的起点将会迎来更加美好的未来。 愿你在新的旅程中，保持魔怔的笑容，保持优柔寡断的坚持，保持执着的追求。愿你的人生之路，一帆风顺，充满阳光与希望。 再见了，亲爱的小粉兔。祝你一切都好。 真诚的，[你的名字] 转载自 xht 根据上述材料，给将要离任的小粉兔写一篇小作文。 DeepSeek-R1 嗯，用户要求我根据材料为即将离任的小粉兔写一篇小作文。材料中描述的小粉兔有\"魔怔又独特\"“优柔寡断”\"执着\"等特点，用户提供的示例作文已经很好地展现了这些特质。 我注意到用户给的示例作文写得挺感人的，用了不少温暖的语言表达感谢和祝福。看来用户希望我能写一篇类似风格但更丰富的小作文，重点突出小粉兔的个性特点和贡献。 用户可能希望这篇小作文能用于告别场合，比如在送别会或纪念册上使用。语气应该真挚温暖，带点文艺感但不要太正式。可以加入一些具体的场景描写，比如\"茶水间飘着咖啡香\"这样的细节，让文字更有画面感。 小粉兔的个性很鲜明：\"魔怔\"可以理解为活泼有趣，\"优柔寡断\"说明他做事谨慎，\"执着\"则体现他的坚持。这些特点都要在作文中自然展现，不要变成简单的标签罗列。 结构上可以这样安排：开头表达不舍，中间回忆具体事例展现个性，最后送上祝福。要注意避免过于伤感，保持温暖积极的基调。可以用\"胡萝卜便签\"这样的细节来体现独特性，比单纯说\"你很特别\"更有说服力。 用户给的示例中有些句子写得很好，比如\"用魔怔点亮日常，用优柔酝酿思考，用执着浇筑热爱\"，这种排比句很有力量。我可以借鉴这种写法，但要用不同的表达方式。祝福语部分要避免套话，最好能呼应前文提到的个性特点。 对了，还要注意篇幅控制。用户给的示例大约300字，这个长度比较合适，既能表达情感又不会太长。最后落款用\"全体伙伴\"比个人署名更合适，因为看起来是代表团队写的告别信。 给即将离任的小粉兔 小粉兔，当告别的风终于吹至门前，茶水间里飘着咖啡香，却忽然掺进了一丝不易察觉的涩味。我们心中纵然有万般不舍，此刻亦只能以最真挚的言语为你送行。 你存在的日子，本身就是一幅奇趣的涂鸦——那“魔怔”的灵光一闪常如闪电划破沉闷，而“优柔”的思虑又如细雨，耐心浸润着每个待解的难题。你像一位持灯的漫步者，在“执着”的驱动下，不倦地叩问每一扇未知的门扉，将看似微小的光芒聚拢成可贵的暖意。那一次，项目陷入泥沼，是你用近乎“魔怔”的巧思，将僵局点化成了机遇；当众人犹疑，又是你“优柔”下的反复斟酌，为前路铺就了踏实的路基；最终，也唯有你那份不熄的“执着”，将混沌的蓝图浇铸成了清晰的现实。你以独特的方式，默默雕刻着团队日常的质地与温度。 离别虽在眼前，但你留下的并非虚空。那些欢笑、那些探求的轨迹、那些温柔的坚持，已如星辰嵌入我们记忆的夜空。它们不仅是我们前行的路标，更是你存在过的永恒证词——如同你曾悄悄贴在大家屏幕边缘的胡萝卜便签，提醒着笨拙世界里那份未被磨灭的纯真与热望。 愿你今后每一步，都踏在属于你的柔软草甸上。请继续以那独一无二的姿态前行：用魔怔点亮日常，用优柔酝酿思考，用执着浇筑热爱。请相信，你此去山高水长，身后总有星光映照——那是我们永不熄灭的祝福目光，在时间深处为你低语： 愿君前路，常有星光低语；纵行千里，犹有故园灯明。","date":"2024-03-01","tags":["休闲·娱乐"]}]